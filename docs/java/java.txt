
Java核心技术36讲


1 谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？
  
  Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“一次编译，到处执行”（Compile once，run anywhere），
能够非常容易地获得跨平台能力；另外就是垃圾收集（GC，Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配
内存，大部分情况下，程序员不需要自己操心内存的分配和回收。
  
  我们日常会接触到JRE（Java Runtime Environment）或者JDK（Java Development Kit）。JRE，也就是Java运行环境，包含了JVM和Java
类库，以及一些模块等。而JDK可以看作是JRE的一个超集，提供了更多工具，比如编译器/各种诊断工具等。

  对于“Java是解释执行”这句话，这个说法不太准确。我们开发的Java源代码，首先通过javac编译成为字节码（bytecode），然后，在
运行时，通过Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的JVM，比如我们大多数情况使用的Oracle JDK
提供的Hotspot JVM，都提供了JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成机器码，这
种情况下部分热点代码就属于编译执行，而不是解释执行了。

  众所周知，我们通常把Java分为编译期和运行时。这里说的Java的编译和C/C++是有着不同意义的，Java的编译，编译Java源码生成
“.class”文件，里面实际是字节码，而不是可以直接执行的机器码。Java通过字节码和Java虚拟机（JVM）这种跨平台的抽象，屏蔽了
操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。

  在运行时，JVM会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。主流Java版本中，如JDK8实际是解释和编译混合的一种
模式，即所谓的混合模式（-Xmixed）。


2、请对比Exception 和 Error，另外，运行时异常和一般异常有什么区别？

  Exception 和 Error 都是继承了Throwable类，在Java中只有Throwable类型的示例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。
   
  Exception 和 Error 体现了Java平台设计者对不同异常情况的分类。
  Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。
  Error 是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也
不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。

  Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显示地进行捕获处理，这是编译期检查的一部分。
  不检查异常就是所谓的运行时异常（RuntimeException），类似NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，
具体根据需要来判断是否需要捕获，并不会在编译期强制要求。


  扩展问题
  2.1 你了解哪些Error、Exception或者RuntimeException？
      Error:
            NoClassDefFoundError
      Exception: 
            IOException
			ClassNotFoundException
      RuntimeException:
	        NullPointerException
			ClassCastException
            	  
  2.2 NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
      https://www.cnblogs.com/xing901022/p/4185514.html
	  http://wxl24life.iteye.com/blog/1919359
	  https://blog.csdn.net/magister_feng/article/details/7459151
	  
	  以下是JDK1.6官方文档中对ClassNotFoundException 和 NoClassDefFoundError的描述
	  
	  ClassNotFoundException:
	  Thrown when an application tries to load in a class through its string name using:
      The forName method in class Class.
      The findSystemClass method in class ClassLoader .
      The loadClass method in class ClassLoader.
      but no definition for the class with the specified name could be found.
	  
	  NoClassDefFoundError:
	  Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class 
	  (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.
	  The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.
	  
  异常处理最佳实践原则
  (1)尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常；
  (2)不要生吞异常（也就是捕获了异常，但不做任何处理// Ignore it）;
  (3)在产品代码中不允许使用e.printStackTrace();处理异常，应该使用产品日志，详细输出到日志系统里；
  (4)Throw early，catch late
  (5)仅捕获必要的代码段，尽量不要一个大的try包住整段代码
  (6)尽量不要使用异常控制代码流程
  
  Java异常处理机制带来的性能问题
  (1)try-catch 代码段会产生额外的性能开销
  (2)Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作
  

3、谈谈final、finally、finalize有什么不同？
  
  final可以修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final修饰的变量是不可以修改的，而final修饰的方法是不可以重写的（override）。
  
  finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock等动作。

  finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前，完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK1.9开始被标记为deprecated。
  
  最佳实践
  推荐使用final关键字来明确表示我们代码的语义、逻辑意图
  （1）我们可以将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的；
  （2）使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误；
  （3）final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，
       有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。
	   
  注意：finally的特例代码
  try {
    // do something
    System.exit(1);
  } finally{
    System.out.println(“Print from finally”);
  }
  上面 finally 里面的代码可不会被执行的哦，这是一个特例。

  
4 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？

  不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。
  
  强引用（"Strong" Reference）
  就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。
  对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，
  当然具体回收时机还是要看垃圾收集策略。
  
  软引用（SoftReference）
  是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。
  JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，
  当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
  
  弱引用（WeakReference）
  并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。
  这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。
  
  幻象引用
  有时候也翻译成虚引用，你不能通过它访问对象。
  幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，也有人利用幻象引用监控对象的创建和销毁。 
  
  知识扩展
  （1）对象可达性状态流转分析
	
  对象创建-->对象初始化-->强引用状态-->软引用-->弱引用-->finalize-->幻象引用--unreachable
                                |          |_________________|
								|____________________________|		  				
                                |_________|        | 
								|__________________|
  
  
  Java 定义的不同可达性级别（reachability level）：
  
  强可达（Strongly Reachable）
  就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。
  
  软可达（Softly Reachable）
  就是当我们只能通过软引用才能访问到对象的状态。
  
  弱可达（Weakly Reachable）
  类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。
  这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。
  
  幻象可达（Phantom Reachable）
  就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。
  
  不可达（unreachable）
  意味着对象可以被清除了。
  
  
  判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑。
  
  所有引用类型，都是抽象类 java.lang.ref.Reference 的子类，它提供了 get() 方法：
  T get() 
  
  除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。
  这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！
  
  所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。
  
  如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。
  所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路
  
  
5、理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？

  String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，
  所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，
  所以相关操作的效率往往对应用性能有明显影响。
  
  StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，它是 Java 1.5 中新增的，我们可以用 append 或者 add 方法，
  把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，
  所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。
  
  StringBuilder 在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。
  
  
  知识扩展
  
  (1) 字符串设计和实现
  String 是 Immutable 类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改；
  StringBuffer 的线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的，非常直白；
  为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，
  二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。
  
  (2) 字符串缓存
  String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。
  在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。
  一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。
  
  但是一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，
  也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。所以，如果使用不当，OOM 就会光顾
  
  在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。
  
  Intern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；
  另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。
  
  幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，
  是 JVM 底层的改变，并不需要 Java 类库做什么修改。
  注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：-XX:+UseStringDeduplication
  
  (3) String 自身的演化
  Java 的字符串，在历史版本中，它是使用 char 数组来存数据的，这样非常直接。但是 Java 中的 char 是两个 bytes 大小，
  拉丁语系语言的字符，根本就不需要太宽的 char，这样无区别的实现就造成了一定的浪费。
  
  在 Java 9 中，引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。将数据存储方式从 char 数组，
  改变为一个 byte 数组加上一个标识编码的所谓 coder，并且将相关字符串操作类都进行了修改。
  虽然底层实现发生了这么大的改变，但是 Java 字符串的行为并没有任何大的变化，所以这个特性对于绝大部分应用来说是透明的，绝大部分情况不需要修改已有代码。
  

6、谈谈 Java 反射机制，动态代理是基于什么原理？

  题外话
  编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。
  与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换。
  那么，如何分类 Java 语言呢？通常认为，Java 是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。
  
  反射机制是Java语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。
  通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。
  
  动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做的，比如用来包装RPC调用、面向切面的编程（AOP）。
  实现动态代理的方式很多，比如JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，
  类似ASM、cglib（基于ASM）、Javassist等。
  
  
7、int 和 Integer 有什么区别？谈谈Integer的值缓存范围？

  int 是我们常说的整型数字，是Java的8个原始数据类型（Primitive Types，boolean、byte、short、char、int、float、double、long）之一。
  Java语言虽然号称一切都是对象，但是原始数据类型是例外。
  
  Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间转换等。在Java 5中，引入了自动装箱和自动拆箱功能
  （boxing/unboxing），Java可以根据上下文，自动进行转换，极大地简化了相关编程。
  
  关于Integer的值缓存，这涉及Java 5中另一个改进。构建Integer对象的传统方式是直接调用构造器，直接new一个对象。但是根据实践，我们发现大部分数据操作都是集中在
  有限的、较小的数值范围，因而，在Java 5中新增了静态工厂方法valueOf，在调用它的时候会利用一个缓冲机制，带来了明显的性能改进。按照Javadoc，这个值默认缓冲是
  -128到127之间。
  
  扩展问题
  （1）自动装箱/自动拆箱，发生在编译阶段还是运行时？
       编译阶段。
  （2）使用静态工厂方法valueOf会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？
       起作用。
	   
  
  
  
  
  
  
  
  
  
  

  