
Java核心技术36讲


1 谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？
  
  Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“一次编译，到处执行”（Compile once，run anywhere），
能够非常容易地获得跨平台能力；另外就是垃圾收集（GC，Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配
内存，大部分情况下，程序员不需要自己操心内存的分配和回收。
  
  我们日常会接触到JRE（Java Runtime Environment）或者JDK（Java Development Kit）。JRE，也就是Java运行环境，包含了JVM和Java
类库，以及一些模块等。而JDK可以看作是JRE的一个超集，提供了更多工具，比如编译器/各种诊断工具等。

  对于“Java是解释执行”这句话，这个说法不太准确。我们开发的Java源代码，首先通过javac编译成为字节码（bytecode），然后，在
运行时，通过Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的JVM，比如我们大多数情况使用的Oracle JDK
提供的Hotspot JVM，都提供了JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成机器码，这
种情况下部分热点代码就属于编译执行，而不是解释执行了。

  众所周知，我们通常把Java分为编译期和运行时。这里说的Java的编译和C/C++是有着不同意义的，Java的编译，编译Java源码生成
“.class”文件，里面实际是字节码，而不是可以直接执行的机器码。Java通过字节码和Java虚拟机（JVM）这种跨平台的抽象，屏蔽了
操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。

  在运行时，JVM会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。主流Java版本中，如JDK8实际是解释和编译混合的一种
模式，即所谓的混合模式（-Xmixed）。


2、请对比Exception 和 Error，另外，运行时异常和一般异常有什么区别？

  Exception 和 Error 都是继承了Throwable类，在Java中只有Throwable类型的示例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。
   
  Exception 和 Error 体现了Java平台设计者对不同异常情况的分类。
  Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。
  Error 是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也
不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。

  Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显示地进行捕获处理，这是编译期检查的一部分。
  不检查异常就是所谓的运行时异常（RuntimeException），类似NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，
具体根据需要来判断是否需要捕获，并不会在编译期强制要求。


  扩展问题
  2.1 你了解哪些Error、Exception或者RuntimeException？
      Error:
            NoClassDefFoundError
      Exception: 
            IOException
			ClassNotFoundException
      RuntimeException:
	        NullPointerException
			ClassCastException
            	  
  2.2 NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
      https://www.cnblogs.com/xing901022/p/4185514.html
	  http://wxl24life.iteye.com/blog/1919359
	  https://blog.csdn.net/magister_feng/article/details/7459151
	  
	  以下是JDK1.6官方文档中对ClassNotFoundException 和 NoClassDefFoundError的描述
	  
	  ClassNotFoundException:
	  Thrown when an application tries to load in a class through its string name using:
      The forName method in class Class.
      The findSystemClass method in class ClassLoader .
      The loadClass method in class ClassLoader.
      but no definition for the class with the specified name could be found.
	  
	  NoClassDefFoundError:
	  Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class 
	  (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.
	  The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.
	  
  异常处理最佳实践原则
  (1)尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常；
  (2)不要生吞异常（也就是捕获了异常，但不做任何处理// Ignore it）;
  (3)在产品代码中不允许使用e.printStackTrace();处理异常，应该使用产品日志，详细输出到日志系统里；
  (4)Throw early，catch late
  (5)仅捕获必要的代码段，尽量不要一个大的try包住整段代码
  (6)尽量不要使用异常控制代码流程
  
  Java异常处理机制带来的性能问题
  (1)try-catch 代码段会产生额外的性能开销
  (2)Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作
  

3、谈谈final、finally、finalize有什么不同？
  
  final可以修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final修饰的变量是不可以修改的，而final修饰的方法是不可以重写的（override）。
  
  finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock等动作。

  finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前，完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK1.9开始被标记为deprecated。
  
  最佳实践
  推荐使用final关键字来明确表示我们代码的语义、逻辑意图
  （1）我们可以将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的；
  （2）使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误；
  （3）final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，
       有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。
	   
  注意：finally的特例代码
  try {
    // do something
    System.exit(1);
  } finally{
    System.out.println(“Print from finally”);
  }
  上面 finally 里面的代码可不会被执行的哦，这是一个特例。

  
4 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？

  不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。
  
  强引用（"Strong" Reference）
  就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。
  对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，
  当然具体回收时机还是要看垃圾收集策略。
  
  软引用（SoftReference）
  是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。
  JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，
  当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
  
  弱引用（WeakReference）
  并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。
  这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。
  
  幻象引用
  有时候也翻译成虚引用，你不能通过它访问对象。
  幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，也有人利用幻象引用监控对象的创建和销毁。 
  
  知识扩展
  （1）对象可达性状态流转分析
	
  对象创建-->对象初始化-->强引用状态-->软引用-->弱引用-->finalize-->幻象引用--unreachable
                                |          |_________________|
								|____________________________|		  				
                                |_________|        | 
								|__________________|
  
  
  Java 定义的不同可达性级别（reachability level）：
  
  强可达（Strongly Reachable）
  就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。
  
  软可达（Softly Reachable）
  就是当我们只能通过软引用才能访问到对象的状态。
  
  弱可达（Weakly Reachable）
  类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。
  这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。
  
  幻象可达（Phantom Reachable）
  就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。
  
  不可达（unreachable）
  意味着对象可以被清除了。
  
  
  判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑。
  
  所有引用类型，都是抽象类 java.lang.ref.Reference 的子类，它提供了 get() 方法：
  T get() 
  
  除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。
  这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！
  
  所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。
  
  如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。
  所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路
  
  
  
  
  
  
  
  
  
  
  
  
  

  