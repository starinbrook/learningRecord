
Java核心技术36讲


1 谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？
  
  Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“一次编译，到处执行”（Compile once，run anywhere），
能够非常容易地获得跨平台能力；另外就是垃圾收集（GC，Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配
内存，大部分情况下，程序员不需要自己操心内存的分配和回收。
  
  我们日常会接触到JRE（Java Runtime Environment）或者JDK（Java Development Kit）。JRE，也就是Java运行环境，包含了JVM和Java
类库，以及一些模块等。而JDK可以看作是JRE的一个超集，提供了更多工具，比如编译器/各种诊断工具等。

  对于“Java是解释执行”这句话，这个说法不太准确。我们开发的Java源代码，首先通过javac编译成为字节码（bytecode），然后，在
运行时，通过Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的JVM，比如我们大多数情况使用的Oracle JDK
提供的Hotspot JVM，都提供了JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成机器码，这
种情况下部分热点代码就属于编译执行，而不是解释执行了。

  众所周知，我们通常把Java分为编译期和运行时。这里说的Java的编译和C/C++是有着不同意义的，Java的编译，编译Java源码生成
“.class”文件，里面实际是字节码，而不是可以直接执行的机器码。Java通过字节码和Java虚拟机（JVM）这种跨平台的抽象，屏蔽了
操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。

  在运行时，JVM会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。主流Java版本中，如JDK8实际是解释和编译混合的一种
模式，即所谓的混合模式（-Xmixed）。


2、请对比Exception 和 Error，另外，运行时异常和一般异常有什么区别？

  Exception 和 Error 都是继承了Throwable类，在Java中只有Throwable类型的示例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。
   
  Exception 和 Error 体现了Java平台设计者对不同异常情况的分类。
  Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。
  Error 是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也
不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。

  Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显示地进行捕获处理，这是编译期检查的一部分。
  不检查异常就是所谓的运行时异常（RuntimeException），类似NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，
具体根据需要来判断是否需要捕获，并不会在编译期强制要求。


  扩展问题
  2.1 你了解哪些Error、Exception或者RuntimeException？
      Error:
            NoClassDefFoundError
      Exception: 
            IOException
			ClassNotFoundException
      RuntimeException:
	        NullPointerException
			ClassCastException
            	  
  2.2 NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
      https://www.cnblogs.com/xing901022/p/4185514.html
	  http://wxl24life.iteye.com/blog/1919359
	  https://blog.csdn.net/magister_feng/article/details/7459151
	  
	  以下是JDK1.6官方文档中对ClassNotFoundException 和 NoClassDefFoundError的描述
	  
	  ClassNotFoundException:
	  Thrown when an application tries to load in a class through its string name using:
      The forName method in class Class.
      The findSystemClass method in class ClassLoader .
      The loadClass method in class ClassLoader.
      but no definition for the class with the specified name could be found.
	  
	  NoClassDefFoundError:
	  Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class 
	  (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.
	  The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.
	  
  异常处理最佳实践原则
  (1)尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常；
  (2)不要生吞异常（也就是捕获了异常，但不做任何处理// Ignore it）;
  (3)在产品代码中不允许使用e.printStackTrace();处理异常，应该使用产品日志，详细输出到日志系统里；
  (4)Throw early，catch late
  (5)仅捕获必要的代码段，尽量不要一个大的try包住整段代码
  (6)尽量不要使用异常控制代码流程
  
  Java异常处理机制带来的性能问题
  (1)try-catch 代码段会产生额外的性能开销
  (2)Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作
  

3、谈谈final、finally、finalize有什么不同？
  
  final可以修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final修饰的变量是不可以修改的，而final修饰的方法是不可以重写的（override）。
  
  finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock等动作。

  finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前，完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK1.9开始被标记为deprecated。
  
  最佳实践
  推荐使用final关键字来明确表示我们代码的语义、逻辑意图
  （1）我们可以将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的；
  （2）使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误；
  （3）final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，
       有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。
	   
  注意：finally的特例代码
  try {
    // do something
    System.exit(1);
  } finally{
    System.out.println(“Print from finally”);
  }
  上面 finally 里面的代码可不会被执行的哦，这是一个特例。

  
