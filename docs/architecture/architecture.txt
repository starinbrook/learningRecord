
* 架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑和实现。

1、架构是什么？

   架构是顶层设计；
   框架是面向编程或配置的半成品；
   组件是从技术维度上的复用；
   模块是从业务维度上职责的划分；
   系统是相互协同可运行的实体。
   
   框架关注的是“规范”，架构关注的是“结构”。
   框架的英文是 Framework，架构的英文是 Architecture。
   
   软件架构指软件系统的顶层结构：
   首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。
   其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。
   第三，维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。
   
2、架构设计历史背景

   软件架构的出现有其历史必然性。
   20 世纪 60 年代第一次软件危机引出了“结构化编程”，创造了“模块”概念；
   20 世纪 80 年代第二次软件危机引出了“面向对象编程”，创造了“对象”概念；
   到了 20 世纪 90 年代“软件架构”开始流行，创造了“组件”概念。
   我们可以看到，“模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。
   
   一个成功的软件设计是要适应并满足业务需求，同时不断“演化”的。设计需要根据业务的变化、技术的发展不断进行“演进”，这就决定了这是一个动态活动，出现新问题，解决新问题，没有所谓的“一招鲜”。
   
   整个软件技术发展的历史，其实就是一部与“复杂度”斗争的历史，架构的出现也不例外
   
3、架构设计的目的
   
   架构设计的主要目的是为了解决软件系统复杂度带来的问题。
   
   通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。
   架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。
   理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。

4 复杂度的来源――高性能

  （1）单台计算机内部为了高性能带来的复杂度
   手工操作―>批处理操作系统―>多进程（分时系统）―>多线程（分时系统）―>多CPU（真正并行）

   如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术并不是最新的
   就是最好的，也不是非此即彼的选择。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程
   同样很复杂。  

  （2）多台计算机集群为了高性能带来的复杂度

   方式一：任务分配
          增加服务器，每个服务器上运行着相同的业务逻辑

          需要增加一个任务分配器
          任务分配器和真正的业务服务器之间有连接和交互
          任务分配器需要增加分配算法

   方式二：任务分解
          把一个大且复杂的业务系统，拆分成多个小而简单的业务系统，例如微信后台架构从逻辑上将业务进行了拆分，拆分成多个子业务，
          包括：接入/注册登陆/消息/摇一摇/漂流瓶/聊天/视频/朋友圈等，各个子业务系统单独部署到不同的服务器上，也就是说任务分解
          也增加了服务器数量，但是每个服务器上运行不同的业务逻辑
		  
5、复杂度的来源――高可用
         
    高可用：系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。
	关键点：无中断
	系统高可用方案有很多，但本质上都是通过“冗余”来实现高可用。
    
	高可用的“冗余”解决方案，单纯从形式上来看，和高性能是一样的，都是通过增加更多机器来达到目的，但其实本质上是有根本区别的：
	高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元；
	
   （1）计算高可用
        
		任务分配
		        双机架构
				        主备：单纯的一台机器在跑流量，另一台机器实时地同步数据库，一旦主机宕机，备机立刻进入工作状态
						    冷备  冷备份服务器（cold server），平常情况下是关机状态，只有当主服务器宕机才开机
							温备  温备份服务器（warm server），周期性开机，根据主服务器内容进行更新，然后关机
							热备  热备份服务器（hot server），时刻处于开机状态，同主机保持同步，主机宕机时，可以随时启用热备份服务器
						主主：两台机都是同时工作，有真正做到负载均衡的作用
				集群架构（总数m + n）
				        m 主 n 备
   
   （2）存储高可用
   
        数据 + 逻辑 = 业务
		
		无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；
		但如果完全不做冗余，系统的整体高可用又无法保证，所以存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。
		
	
	状态决策（高可用的基础）
	
	（1）独裁式
	     决策者：独立的决策主体，负责收集信息然后进行决策
		 上报者：所有其他冗余的个体，负责将状态信息发送给决策者
		 优点：因为只有一个决策者，所以不会出现决策混乱的问题
		 缺点：决策者本身故障时，整个系统就无法实现准确的状态决策
	
	（2）协商式
	     两个独立个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是主备决策。
		 这个架构的基本协商规则可以设计成：
         * 2 台服务器启动时都是备机。
         * 2 台服务器建立连接。
         * 2 台服务器交换状态信息。
         * 某 1 台服务器做出决策，成为主机；另一台服务器继续保持备机身份
		 优点：架构简单、规则也不复杂
		 缺点：主备连接中断时会出现决策错误
	
	（3）民主式
	     多个独立的个体通过投票的方式进行状态决策，多数取胜
		 缺点：可能会出现“脑裂”
		 
	无论采取什么样的方案，状态决策都不可能做到任何场景下都没有问题，但完全不做高可用方案又会产生更大的问题，如何选取适合系统的高可用方案，
	也是一个复杂的分析、判断和选择的过程。
	

6、复杂度的来源――可扩展性

    可扩展性 指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。

	设计具备良好可扩展性的系统，有两个基本条件：正确预测变化、完美封装变化。
	
	预测变化的复杂性在于：
    （1）不能每个设计点都考虑可扩展性。
    （2）不能完全不考虑可扩展性。
    （3）所有的预测都存在出错的可能性。
	
	对于架构师来说，如何把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，而且没有通用的标准可以简单套上去，更多是靠自己的经验、直觉。
	
	应对变化的方案：
	方案一：将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。
	方案二：提炼出一个“抽象层”和一个“实现层”。抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层。
	
	
7 复杂度的来源――低成本/安全/规模

    *低成本
	
	当我们设计“高性能”“高可用”的架构时，通用的手段都是增加更多服务器来满足“高性能”和“高可用”的要求；
	而低成本正好与此相反，我们需要减少服务器的数量才能达成低成本的目标。
	因此，低成本本质上是与高性能和高可用冲突的，所以低成本很多时候不会是架构设计的首要目标，而是架构设计的附加约束。
	也就是说，我们首先设定一个成本目标，当我们根据高性能、高可用的要求设计出方案时，评估一下方案是否能满足成本目标，
	如果不行，就需要重新设计架构；如果无论如何都无法设计出满足成本要求的方案，那就只能找老板调整成本目标了。
	
	低成本给架构设计带来的主要复杂度体现在，往往只有“创新”才能达到低成本目标。
	这里的“创新”既包括开创一个全新的技术领域（这个要求对绝大部分公司太高），也包括引入新技术，
	如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。
	
	*安全
	
	从技术的角度来讲，安全可以分为两类：一类是功能上的安全，一类是架构上的安全。
	
	（1）功能安全
	常见的 XSS 攻击、CSRF 攻击、SQL 注入、Windows 漏洞、密码破解等
	本质上是因为系统实现有漏洞，黑客有了可乘之机。黑客会利用各种漏洞潜入系统，这种行为就像小偷一样，
	黑客和小偷的手法都是利用系统或家中不完善的地方潜入，并进行破坏或者盗取。因此形象地说，功能安全其实就是“防小偷”。
	
	从实现的角度来看，功能安全更多地是和具体的编码相关，与架构关系不大。
	
	很多开发框架都内嵌了常见的安全功能，能够大大减少安全相关功能的重复开发，但框架只能预防常见的安全漏洞和风险（常见的 XSS 攻击、CSRF 攻击、SQL 注入等），
	无法预知新的安全问题，而且框架本身很多时候也存在漏洞
	
	所以功能安全是一个逐步完善的过程，而且往往都是在问题出现后才能有针对性的提出解决方案，我们永远无法预测系统下一个漏洞在哪里，
	也不敢说自己的系统肯定没有任何问题。
	
	换句话讲，功能安全其实也是一个“攻”与“防”的矛盾，只能在这种攻防大战中逐步完善，不可能在系统架构设计的时候一劳永逸地解决。
	
	（2）架构安全
	如果说功能安全是“防小偷”，那么架构安全就是“防强盗”。强盗会直接用大锤将门砸开，或者用炸药将围墙炸倒；
	小偷是偷东西，而强盗很多时候就是故意搞破坏，对系统的影响也大得多。
	
	传统的架构安全主要依靠防火墙
	
	防火墙最基本的功能就是隔离网络，通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流。
	
	防火墙的功能虽然强大，但性能一般，所以在传统的银行和企业应用领域应用较多。
	但在互联网领域，防火墙的应用场景并不多。因为互联网的业务具有海量用户访问和高并发的特点，防火墙的性能不足以支撑
	
	基于上述原因，互联网系统的架构安全目前并没有太好的设计手段来实现，更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现。
	
	*规模
	
	规模带来复杂度的主要原因就是“量变引起质变”，当数量超过一定的阈值后，复杂度会发生质的变化。常见的规模带来的复杂度有：

   （1） 功能越来越多，导致系统复杂度指数级上升
       
	     系统的复杂度 = 功能数量 + 功能之间的连接数量
		 
		 例如，某个系统开始只有 3 大功能，后来不断增加到 8 大功能，虽然还是同一个系统，但复杂度已经相差很大了，具体相差多大呢？
		 假设系统间的功能都是两两相关：
		 3 个功能的系统复杂度 = 3 + 3 = 6
         8 个功能的系统复杂度 = 8 + 28 = 36
		 
   （2） 数据越来越多，系统复杂度发生质变
       
	     与功能类似，系统数据越来越多时，也会由量变带来质变，最近几年火热的“大数据”就是在这种背景下诞生的。
		 
		 目前的大数据理论基础是 Google 发表的三篇大数据相关论文，其中 
		 Google File System 是大数据文件存储的技术理论，
		 Google Bigtable 是列式数据存储的技术理论，
		 Google MapReduce 是大数据运算的技术理论，这三篇技术论文各自开创了一个新的技术领域。
		 
		 即使我们的数据没有达到大数据规模，数据的增长也可能给系统带来复杂性。
		 最典型的例子莫过于使用关系数据库存储数据，以 MySQL 为例，MySQL 单表的数据因不同的业务和应用场景会有不同的最优值，
		 但不管怎样都肯定是有一定的限度的，一般推荐在 5000 万行左右。如果因为业务的发展，单表数据达到了 10 亿行，就会产生很多问题
		 
		 因此，当 MySQL 单表数据量太大时，我们必须考虑将单表拆分为多表，这个拆分过程也会引入更多复杂性，例如：
		 拆表的规则是什么？
		 拆完表后查询如何处理？
		 
	
8、架构设计三原则

    *合适原则
	
	合适原则宣言：“合适优于业界领先”。
	真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。
	
	
	*简单原则
	
	简单原则宣言：“简单优于复杂”。
	“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。
	
	软件领域的复杂性体现在两个方面：
	(1) 结构的复杂性
	结构复杂的系统几乎毫无例外具备两个特点：组成复杂系统的组件数量更多；同时这些组件之间的关系也更加复杂。
	
	结构上的复杂性存在的第一个问题是，组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。
	    这个概率可以算出来，假设组件的故障率是 10%（有 10% 的时间不可用），那么
		有 3 个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）= 72.9%，
		有 5 个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）×（1-10%）×（1-10%）=59%，
		两者的可用性相差 13%。
	结构上的复杂性存在的第二个问题是，某个组件改动，会影响关联的所有组件，这些被影响的组件同样会继续递归影响更多的组件。
	    这个问题会影响整个系统的开发效率，因为一旦变更涉及外部系统，需要协调各方统一进行方案评估、资源协调、上线配合。
	结构上的复杂性存在的第三个问题是，定位一个复杂系统中的问题总是比简单系统更加困难。
	    首先是组件多，每个组件都有嫌疑，因此要逐一排查；
		其次组件间的关系复杂，有可能表现故障的组件并不是真正问题的根源。
		
	(2) 逻辑的复杂性
	逻辑复杂的组件，一个典型特征就是单个组件承担了太多的功能。
	
	结构的复杂性 和 逻辑的复杂性 需要达到一个平衡：
	为了降低结构复杂性，减少组件数量，那么单个组件的逻辑复杂性增高；为了降低逻辑复杂性，把复杂逻辑拆分到多个组件中，又增加了结构复杂性
	
	无论是结构的复杂性，还是逻辑的复杂性，都会存在各种问题，所以架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。
	
	《UNIX 编程艺术》总结的 KISS（Keep It Simple, Stupid!）原则一样适应于架构设计。
	
	
	*演化原则
	
	演化原则宣言：“演化优于一步到位”。
	
	软件架构需要根据业务发展不断变化。
	
	软件架构设计过程：
	首先，设计出来的架构要满足当时的业务需要。
    其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。
    第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。
	
	架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。
	应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。
	
	
	
	

    
   
   